<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>웹사이트 리소스 분석</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .visualization-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 2rem;
            padding: 2rem;
        }
        
        .visualization-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            margin-bottom: 2rem;
        }
        
        .visualization-card h4 {
            color: #1a1a1a;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }
        
        .viz-description {
            color: #666;
            font-size: 0.9rem;
            margin-top: 1rem;
        }
        
        .treemap-cell {
            cursor: pointer;
            transition: opacity 0.2s;
        }
        
        .treemap-cell:hover {
            opacity: 0.8;
        }

        .radar-chart-wrapper {
            display: flex;
            justify-content: center;
        }
    </style>
</head>
<body>

    <div class="content-card">
        <!-- 리소스 타입별 도넛 차트 -->
        <div class="content-card">
            <h3 style="font-weight: bold;">리소스 타입별 용량 분포</h3>
            <div id="resource-donut"></div>
        </div>
    
        <!-- 실시간 추이 그래프 -->
        <div class="mt-5">
            <h4>실시간 공공기관 탄소배출량 추이</h4>
            <svg id="multiline" width="800" height="400"></svg>
        </div>
    </div>


    <div class="visualization-container">
        <!-- 리소스 트리맵 -->
        <div class="visualization-card">
            <h4>웹사이트 리소스 구성 분석</h4>
            <div id="resource-treemap"></div>
            <p class="viz-description">각 리소스 타입별 용량을 시각적으로 표현하여 최적화가 필요한 영역을 파악할 수 있습니다.</p>
        </div>

        <!-- 시계열 개선 추적 -->
        <div class="visualization-card">
            <h4>탄소 배출량 개선 추이</h4>
            <div id="improvement-timeline"></div>
            <p class="viz-description">매월 측정된 탄소 배출량의 변화를 추적하여 개선 효과를 확인할 수 있습니다.</p>
        </div>

        <!-- 벤치마크 레이더 차트 -->
        <div class="visualization-card">
            <h4>웹사이트 성능 벤치마크</h4>
            <div id="performance-radar" class="radar-chart-wrapper"></div>
            <p class="viz-description">다양한 성능 지표를 동시에 비교하여 종합적인 최적화 상태를 파악할 수 있습니다.</p>
        </div>

        <!-- 최적화 기회 버블 차트 -->
        <div class="visualization-card">
            <h4>최적화 우선순위 분석</h4>
            <div id="optimization-bubble"></div>
            <p class="viz-description">리소스별 크기와 최적화 가능성을 시각화하여 효율적인 개선 계획을 수립할 수 있습니다.</p>
        </div>
    </div>

    <script>
        // 1. 트리맵 구현
        const treemapData = {
            imageBytes: 2500000,
            jsBytes: 1500000,
            cssBytes: 500000,
            htmlBytes: 100000,
            otherBytes: 400000
        };

        const drawTreemap = (data) => {
            const width = 600;
            const height = 400;
            
            const svg = d3.select("#resource-treemap")
                .append("svg")
                .attr("width", width)
                .attr("height", height);
            
            const root = d3.hierarchy({
                children: [
                    {name: "이미지", value: data.imageBytes},
                    {name: "JavaScript", value: data.jsBytes},
                    {name: "CSS", value: data.cssBytes},
                    {name: "HTML", value: data.htmlBytes},
                    {name: "기타", value: data.otherBytes}
                ]
            }).sum(d => d.value);
            
            const treemap = d3.treemap()
                .size([width, height])
                .padding(1);
            
            treemap(root);
            
            const color = d3.scaleOrdinal()
                .domain(["이미지", "JavaScript", "CSS", "HTML", "기타"])
                .range(["#ff9999", "#99ff99", "#9999ff", "#ffff99", "#ff99ff"]);
            
            const cells = svg.selectAll("g")
                .data(root.leaves())
                .join("g")
                .attr("transform", d => `translate(${d.x0},${d.y0})`);
            
            cells.append("rect")
                .attr("width", d => d.x1 - d.x0)
                .attr("height", d => d.y1 - d.y0)
                .attr("fill", d => color(d.data.name))
                .attr("class", "treemap-cell");
            
            cells.append("text")
                .selectAll("tspan")
                .data(d => {
                    return [
                        d.data.name,
                        `${(d.data.value / 1024 / 1024).toFixed(2)}MB`
                    ];
                })
                .join("tspan")
                .attr("x", 3)
                .attr("y", (d, i) => 13 + i * 10)
                .attr("fill", "black")
                .text(d => d);
        };

        // 2. 시계열 차트 구현
        const timelineData = Array.from({length: 12}, (_, i) => ({
            month: i + 1,
            value: Math.random() * 100 + 50
        }));

        const drawTimelineChart = (data) => {
            const width = 600;
            const height = 400;
            const margin = {top: 20, right: 30, bottom: 30, left: 40};

            const svg = d3.select("#improvement-timeline")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const x = d3.scaleLinear()
                .domain([1, 12])
                .range([margin.left, width - margin.right]);

            const y = d3.scaleLinear()
                .domain([0, d3.max(data, d => d.value)])
                .range([height - margin.bottom, margin.top]);

            const line = d3.line()
                .x(d => x(d.month))
                .y(d => y(d.value));

            svg.append("path")
                .datum(data)
                .attr("fill", "none")
                .attr("stroke", "#00824c")
                .attr("stroke-width", 2)
                .attr("d", line);

            // Add axes
            svg.append("g")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).ticks(12));

            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y));
        };

        // 3. 레이더 차트 구현
        const radarData = [
            {axis: "로딩속도", value: 0.8},
            {axis: "이미지최적화", value: 0.6},
            {axis: "캐시활용", value: 0.9},
            {axis: "코드최적화", value: 0.7},
            {axis: "서버응답", value: 0.85}
        ];

        const drawRadarChart = (data) => {
            const width = 500;
            const height = 500;
            const radius = Math.min(width, height) / 2;

            const svg = d3.select("#performance-radar")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", `translate(${width/2},${height/2})`);

            const angleSlice = Math.PI * 2 / data.length;

            // Scale for the radius
            const rScale = d3.scaleLinear()
                .range([0, radius])
                .domain([0, 1]);

            // Draw the background circles
            const levels = 5;
            const circles = svg.selectAll(".grid-circle")
                .data(d3.range(1, levels+1).reverse())
                .join("circle")
                .attr("r", d => radius/levels*d)
                .style("fill", "none")
                .style("stroke", "#ccc")
                .style("stroke-dasharray", "4,4");

            // Draw the axes
            const axes = svg.selectAll(".axis")
                .data(data)
                .join("g")
                .attr("class", "axis");

            axes.append("line")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", (d, i) => rScale(1.1) * Math.cos(angleSlice*i - Math.PI/2))
                .attr("y2", (d, i) => rScale(1.1) * Math.sin(angleSlice*i - Math.PI/2))
                .style("stroke", "#999")
                .style("stroke-width", "1px");

            // Draw the path
            const line = d3.lineRadial()
                .radius(d => rScale(d.value))
                .angle((d, i) => i * angleSlice);

            svg.append("path")
                .datum(data)
                .attr("class", "radar-path")
                .attr("d", line)
                .style("fill", "#00824c")
                .style("fill-opacity", 0.3)
                .style("stroke", "#00824c")
                .style("stroke-width", "2px");

            // Add labels
            axes.append("text")
                .attr("class", "legend")
                .style("font-size", "11px")
                .attr("text-anchor", "middle")
                .attr("dy", "0.35em")
                .attr("x", (d, i) => rScale(1.2) * Math.cos(angleSlice*i - Math.PI/2))
                .attr("y", (d, i) => rScale(1.2) * Math.sin(angleSlice*i - Math.PI/2))
                .text(d => d.axis);
        };

        // 4. 버블 차트 구현
        const bubbleData = [
            {name: "이미지 최적화", size: 50, potential: 80, current: 2.5},
            {name: "JS 번들링", size: 30, potential: 60, current: 1.8},
            {name: "CSS 최적화", size: 20, potential: 40, current: 1.2},
            {name: "캐시 설정", size: 40, potential: 90, current: 3.0},
            {name: "압축 활성화", size: 25, potential: 70, current: 2.0}
        ];

        const drawBubbleChart = (data) => {
            const width = 600;
            const height = 400;
            const margin = {top: 20, right: 20, bottom: 30, left: 40};

            const svg = d3.select("#optimization-bubble")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

            const x = d3.scaleLinear()
                .domain([0, 100])
                .range([margin.left, width - margin.right]);

            const y = d3.scaleLinear()
                .domain([0, 4])
                .range([height - margin.bottom, margin.top]);

            const size = d3.scaleLinear()
                .domain([0, 100])
                .range([5, 30]);

            const color = d3.scaleSequential()
                .domain([0, 100])
                .interpolator(d3.interpolateViridis);

            svg.selectAll("circle")
                .data(data)
                .join("circle")
                .attr("cx", d => x(d.potential))
                .attr("cy", d => y(d.current))
                .attr("r", d => size(d.size))
                .attr("fill", d => color(d.potential))
                .attr("opacity", 0.7)
                .append("title")
                .text(d => d.name);

            // Add axes
            svg.append("g")
                .attr("transform", `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(x).ticks(5));

            svg.append("g")
                .attr("transform", `translate(${margin.left},0)`)
                .call(d3.axisLeft(y).ticks(5));
        };

        
        // 도넛 차트 생성
        function createDonutChart(data) {
    const width = 500;
    const height = 300;
    const radius = Math.min(width, height) / 2;

    const svg = d3.select("#resource-donut")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .append("g")
        .attr("transform", `translate(${width / 2},${height / 2})`);

    const color = d3.scaleOrdinal()
        .domain(data.map(d => d.name))
        .range(['#FF8B5C', '#9B6B9E', '#FFD5C2', '#7AC7A3']);

    const pie = d3.pie()
        .value(d => d.value)
        .sort(null);

    const arc = d3.arc()
        .innerRadius(radius * 0.6)
        .outerRadius(radius * 0.8);

    const path = svg.selectAll("path")
        .data(pie(data))
        .join("path")
        .attr("d", arc)
        .attr("fill", d => color(d.data.name))
        .attr("stroke", "white")
        .style("stroke-width", "2px");

    // 범례 추가
    const legend = svg.append("g")
        .attr("transform", `translate(${radius + 30},-${radius/2})`);

    data.forEach((d, i) => {
        const legendRow = legend.append("g")
            .attr("transform", `translate(0, ${i * 25})`);

        legendRow.append("rect")
            .attr("width", 18)
            .attr("height", 18)
            .attr("fill", color(d.name));

        legendRow.append("text")
            .attr("x", 24)
            .attr("y", 9)
            .attr("dy", "0.35em")
            .text(`${d.name} (${(d.value/1024).toFixed(2)}KB)`);
    });
        }

        // 멀티라인 그래프 생성
        const multilineSvg = d3.select("#multiline");
const margin = {top: 40, right: 80, bottom: 50, left: 60};
const width = +multilineSvg.attr("width") - margin.left - margin.right;
const height = +multilineSvg.attr("height") - margin.top - margin.bottom;

const g = multilineSvg.append("g")
    .attr("transform", `translate(${margin.left},${margin.top})`);

        // 차트 그리기
        drawTreemap(treemapData);
        drawTimelineChart(timelineData);
        drawRadarChart(radarData);
        drawBubbleChart(bubbleData);
    </script>
</body>
</html>